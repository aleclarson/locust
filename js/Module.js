// Generated by CoffeeScript 1.12.7
var Module, Type, assertType, fs, globby, hasKeys, inArray, isType, path, resolveAbsolutePath, sortObject, type;

assertType = require("assertType");

sortObject = require("sortObject");

hasKeys = require("hasKeys");

inArray = require("in-array");

isType = require("isType");

globby = require("globby");

path = require("path");

Type = require("Type");

fs = require("fsx");

type = Type("Lotus_Module");

type.defineArgs([String, String.Maybe]);

type.defineValues(function(modName, modPath) {
  return {
    name: modName,
    path: modPath != null ? modPath : path.resolve(lotus.path, modName),
    files: Object.create(null),
    _loaders: Object.create(null),
    _loading: Object.create(null),
    _crawling: Object.create(null)
  };
});

resolveAbsolutePath = function(newValue) {
  assertType(newValue, String);
  if (path.isAbsolute(newValue)) {
    return newValue;
  }
  return path.resolve(this.path, newValue);
};

type.defineProperties({
  src: {
    value: null,
    willSet: resolveAbsolutePath
  },
  spec: {
    value: null,
    willSet: resolveAbsolutePath
  },
  dest: {
    value: null,
    willSet: resolveAbsolutePath
  }
});

type.initInstance((function() {
  var defaultLoaders;
  defaultLoaders = null;
  return function() {
    if (defaultLoaders == null) {
      defaultLoaders = {
        config: this._loadConfig,
        plugins: this._loadPlugins
      };
    }
    return this.addLoaders(defaultLoaders);
  };
})());

type.defineMethods({
  getFile: function(filePath) {
    var file, mod;
    if (!path.isAbsolute(filePath)) {
      filePath = path.resolve(this.path, filePath);
    }
    if (file = this.files[filePath]) {
      return file;
    }
    if (mod = lotus.modules.resolve(filePath)) {
      this.files[filePath] = file = lotus.File(filePath, mod);
      return file;
    }
    return null;
  },
  getDest: function(filePath, ext) {
    var dest, dir, name, ref, src;
    ref = this, src = ref.src, dest = ref.dest;
    if (!(src && dest)) {
      return null;
    }
    if (!filePath.startsWith(src)) {
      return null;
    }
    dir = path.relative(src, path.dirname(filePath));
    name = path.basename(filePath);
    if (ext) {
      name = name.replace(path.extname(filePath), ext);
    }
    return path.join(dest, dir, name);
  },
  load: function(names) {
    if (isType(names, String)) {
      names = [names];
    }
    assertType(names, Array);
    return Promise.chain(names, (function(_this) {
      return function(name) {
        var base;
        return (base = _this._loading)[name] != null ? base[name] : base[name] = Promise["try"](function() {
          var loader;
          if (loader = _this._loaders[name]) {
            return loader.call(_this);
          } else {
            throw Error("Loader named '" + name + "' does not exist!");
          }
        }).fail(function(error) {
          _this._loading[name] = null;
          throw error;
        });
      };
    })(this));
  },
  crawl: function(pattern, options) {
    var cacheId, ignored;
    if (isType(pattern, Object)) {
      options = pattern;
      pattern = null;
    } else if (!isType(options, Object)) {
      options = {};
    }
    if (!pattern) {
      pattern = [path.join(this.path, "*.js")];
      if (this.dest !== null) {
        pattern.push(path.join(this.dest, "**", "*.js"));
      }
    }
    if (Array.isArray(pattern)) {
      return Promise.all(pattern, (function(_this) {
        return function(pattern) {
          return _this.crawl(pattern, options);
        };
      })(this)).then(function(filesByPattern) {
        var paths, results;
        paths = Object.create(null);
        results = [];
        filesByPattern.forEach(function(files) {
          return files.forEach(function(file) {
            if (paths[file.path]) {
              return;
            }
            paths[file.path] = true;
            return results.push(file);
          });
        });
        return results;
      });
    }
    assertType(pattern, String);
    if (path.isAbsolute(pattern)) {
      throw Error("`pattern` must be relative");
    }
    cacheId = pattern;
    if (ignored = options.ignore) {
      cacheId += ", i: ";
      ignored = Array.isArray(ignored) ? ignored.slice() : ignored.split(/\s*\,\s*/);
      cacheId += ignored.sort().join(", ");
    } else if (options.ignored) {
      throw Error("Invalid option: `ignored`\nAre you looking for `ignore`?");
    }
    if (!options.force) {
      if (this._crawling[cacheId]) {
        return this._crawling[cacheId];
      }
    }
    pattern = path.resolve(this.path, pattern);
    return this._crawling[cacheId] = globby(pattern, {
      ignore: ignored,
      nodir: true
    }).then((function(_this) {
      return function(filePaths) {
        var file, filePath, files, i, len;
        files = [];
        for (i = 0, len = filePaths.length; i < len; i++) {
          filePath = filePaths[i];
          if (file = _this.getFile(filePath)) {
            files.push(file);
          }
        }
        return files;
      };
    })(this)).fail((function(_this) {
      return function(error) {
        delete _this._crawling[cacheId];
        throw error;
      };
    })(this));
  },
  saveConfig: function() {
    var config, configPath, dependencies, devDependencies;
    if (!(config = this.config)) {
      return;
    }
    dependencies = config.dependencies, devDependencies = config.devDependencies;
    if (hasKeys(dependencies)) {
      config.dependencies = sortObject(dependencies);
    } else {
      delete config.dependencies;
    }
    if (hasKeys(devDependencies)) {
      config.devDependencies = sortObject(devDependencies);
    } else {
      delete config.devDependencies;
    }
    config = JSON.stringify(config, null, 2);
    configPath = path.join(this.path, "package.json");
    fs.writeFile(configPath, config + log.ln);
  },
  hasPlugin: function(plugin) {
    if (this.config) {
      return inArray(this.config.plugins, plugin);
    }
    throw Error("Must first load the module's config file!");
  },
  addLoader: function(key, loader) {
    if (loader instanceof Function) {
      this._loaders[key] = loader;
    } else {
      throw TypeError("Loaders must be functions!");
    }
  },
  addLoaders: function(loaders) {
    var key, loader;
    assertType(loaders, Object);
    for (key in loaders) {
      loader = loaders[key];
      this.addLoader(key, loader);
    }
  },
  _loadConfig: function() {
    var configPath, dest, error;
    configPath = path.join(this.path, "package.json");
    if (!fs.isFile(configPath)) {
      error = Error("'package.json' could not be found!");
      return Promise.reject(error);
    }
    this.config = JSON.parse(fs.readFile(configPath));
    if (isType(this.config.src, String)) {
      this.src = this.config.src;
    }
    if (isType(this.config.spec, String)) {
      this.spec = this.config.spec;
    }
    if (isType(this.config.dest, String)) {
      this.dest = this.config.dest;
    } else if (isType(this.config.main, String)) {
      dest = path.dirname(path.join(this.path, this.config.main));
      if (dest !== this.path) {
        this.dest = dest;
      }
    }
  },
  _loadPlugins: function() {
    var i, j, len, len1, loader, name, names, plugins, ref;
    if (!this.config) {
      throw Error("Must load the 'config' first!");
    }
    plugins = new Set;
    if (names = this.config.plugins) {
      for (i = 0, len = names.length; i < len; i++) {
        name = names[i];
        plugins.add(name);
      }
    }
    ref = lotus.modulePlugins;
    for (j = 0, len1 = ref.length; j < len1; j++) {
      name = ref[j];
      plugins.add(name);
    }
    loader = (function(_this) {
      return function(plugin) {
        return plugin.initModule(_this);
      };
    })(this);
    plugins = Array.from(plugins);
    return Promise.all(plugins, (function(_this) {
      return function(name) {
        if (name[0] === ".") {
          name = path.resolve(_this.path, name);
        }
        return lotus.plugins.load(name, loader);
      };
    })(this));
  }
});

type.addMixins(lotus.moduleMixins);

module.exports = Module = type.build();
